# Process ICGC BRCA data
# Yunlong Jiao, 21 April 2016

This script processes data and generates matrices for naive models later to make predictions.

```{r setup}
knitr::opts_chunk$set(error = FALSE, cache.path = "1_processData_cache/")
set.seed(35875954)
source("../../src/func.R")
datapath <- '../../data/BRCA_saved_data/'
```

## Features

Feature matrices are stored at `r datapath`. Note that all feature matrices have to be initially provided by features in rows and patients in cols (to facilitate processing in a universal style). These matrix objects should have a name ending with `[.]vals$`.

```{r features}
# gene expression
load(paste0(datapath, '110_genes_vals.RData'))

# gene expression wrt those present in pathways
load(paste0(datapath, '110_mini_genes_vals.RData'))

# pathway-wise features
load(paste0(datapath, '110_hipathia_matrices.RData'))

# complement of mini.genes from all.genes
stopifnot(rownames(mini.genes.vals) %in% rownames(genes.vals))
other.genes.vals <- genes.vals[setdiff(rownames(genes.vals), rownames(mini.genes.vals)), ]

# get all feature matrices
xlist <- ls(pattern = '[.]vals$')
for (xname in xlist) {
  # process each feature matrices
  x <- get(xname)
  # check no NA values
  stopifnot(!any(is.na(x)))
  # make patients in rows and features in cols
  x <- t(x)
  # reform feature names and check for duplicated names
  colnames(x) <- paste0('X_', gsub('[^[:alnum:]_]', '_', colnames(x)))
  stopifnot(!any(duplicated(rownames(x))))
  stopifnot(!any(duplicated(colnames(x))))
  # assign back
  assign(xname, x)
}
# set samples
samplelist <- unique(lapply(xlist, function(xname) rownames(get(xname))))
stopifnot(length(samplelist) == 1)
samplelist <- unlist(samplelist)
nsample <- length(samplelist)

# create mixed feature matrices
xlist2combn <- list("eff.and.other.genes.vals" = c("eff.vals", "other.genes.vals"), 
                    "path.and.other.genes.vals" = c("path.vals", "other.genes.vals"), 
                    "path.and.genes.vals" = c("path.vals", "genes.vals"))
for (xname in names(xlist2combn)) {
  x <- mget(xlist2combn[[xname]])
  x <- do.call("cbind", x)
  assign(xname, x)
}
xlist <- c(xlist, names(xlist2combn))

# show all feature matrices
xlist
cat('\n-------------> \t preview \t <-------------\n')
for (xname in xlist) {
  cat('\n-------------> \t ', xname, ' \t <-------------\n')
  print(str(get(xname)))
  cat('\n')
}
```

## Groups (multi-class only)

Multiple classes are created from clinical info for classification. There vector objects are named ending with `[.]grps$`.

**NOTE always put THE positive group to the last level in the ordered factor as the evaluation measure such as TPR, FPR will be specific to that level.**

#### Luminal vs Her2 vs Basal (subtypes)

```{r subtype}
y <- read.table(paste0(datapath, 'sampleCancerType.txt'), header = FALSE)
head(y$V2)
unique(y$V2)
subtype.grps <- ordered(gsub('[^[:alnum:]_]', '_', y$V2), levels = c("Luminal", "Her2", "Basal"), labels = c("T1_Luminal", "T2_Her2", "T3_Basal"))
id.na <- is.na(subtype.grps)
subtype.grps <- subtype.grps[!id.na]
names(subtype.grps) <- y$V1[!id.na]
head(subtype.grps)
# sample size (how many labels are available in the sample cohort)
length(sl <- intersect(samplelist, names(subtype.grps)))
# contrasting class size
table(subtype.grps[sl])
```

#### Summary

```{r groups}
# get all groups
ylist <- ls(pattern = '[.]grps$')
# show all groups and their classes
for (yname in ylist) {
  cat('\n-------------> \t summary \t <-------------\n')
  cat('\n-------------> \t ', yname, ' \t <-------------\n')
  print(levels(get(yname)))
  cat('\n')
}
```

## Predictors

See `../../src/func.R` for all predictors implemented. These function objects should all have a name starting with `^predictor`.

```{r predictors}
prlist <- ls(pattern = '^predictor.')
prlist
```

## Kernel matrices

This section computes kernel matrix to accelerate implementation of `kernlab::ksvm`. These kernel matrices are save at `r datapath` and named ending with `[.]kmat$`. Specifically we have the following kernel
- Kendall kernel (Jiao and Vert, 2016) for `r grep("kendall", prlist, ignore.case=T, value=T)`

**NOTE before we compute kernel here **

```{r kmat, message=FALSE}
# kendall kernel
prname <- "predictorKendallSVM"
kernel <- pcaPP::cor.fk
for (xname in xlist) {
  kmatname <- paste(prname, xname, "kmat", sep = ".")
  message(kmatname)
  kmatpath <- paste0(datapath, kmatname, ".RData")
  if (file.exists(kmatpath)) {
    assign(kmatname, get(load(kmatpath)))
  } else {
    x <- get(xname)
    x <- removeConst(x)
    assign(kmatname, computeKernelMatrix(x = x, kernel = kernel))
    save(list = kmatname, file = kmatpath)
  }
}
kmatlist <- ls(pattern = '[.]kmat$')
kmatlist
```

## (Nested) cross validation parameters

```{r cv}
# CV folds for evaluation
nfolds <- 5
nrepeats <- 10
# inner CV folds for tuning predictor
nfolds.inn <- 5
nrepeats.inn <- 1
# indep signif parameters
pthres <- 0.05
test <- "t.test"
method <- "none"
```

## Save up !!

```{r save}
# for cluster jobs, write out full combinations of double nested CV parameters
# - for outter loop, 1:(nfolds * nrepeats) denotes index for outter CV
# - for inner loop, 0 indicates running outter loop evaluation, 1:(nfolds.inn * nrepeats.inn) indicates index for inner CV
param <- expand.grid(as.character(xlist), # feature
                     as.character(ylist), # group
                     as.character(prlist), # predictor
                     as.integer(1:(nfolds * nrepeats)), # outter CV folds index for evaluation
                     as.integer(nfolds), 
                     as.integer(nrepeats), 
                     as.integer(0:(nfolds.inn * nrepeats.inn)), # inner CV folds for tuning predictor
                     as.integer(nfolds.inn), 
                     as.integer(nrepeats.inn), 
                     KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
write.table(param, file = '2_runPredict.txt', quote = FALSE, row.names = FALSE, col.names = FALSE, sep = ' ')
# preview
str(param)

xlist.test <- grep("[.]and[.]|^genes", xlist, value = TRUE, invert = TRUE)
param <- expand.grid(as.character(xlist.test), # feature
                     as.character(ylist), # group
                     as.integer(1:(nfolds * nrepeats)), # outter CV folds index for evaluation
                     as.integer(nfolds), 
                     as.integer(nrepeats), 
                     as.numeric(pthres), 
                     as.character(test), 
                     as.character(method), 
                     KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
write.table(param, file = '4_indepsignif.txt', quote = FALSE, row.names = FALSE, col.names = FALSE, sep = ' ')
# preview
str(param)

# save entire image to be loaded later
save(list = c(xlist, ylist, kmatlist), file = 'dat.RData')
```

# Session info

```{r session_info}
sessionInfo()
```
